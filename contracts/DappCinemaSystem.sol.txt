// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol";
import "./Base64.sol";

contract DappCinemaSystem is ERC1155, Ownable, AccessControl, ERC1155Burnable {
    using Counters for Counters.Counter;
    Counters.Counter private _totalMovies;
    Counters.Counter private _totalSlots;
    Counters.Counter private _totalTickets;

    // Structs from DappShared
    struct MovieStruct {
        uint256 id;
        string name;
        string banner;
        string imageUrl;
        string videoUrl;
        string genre;
        string description;
        string caption;
        string casts;
        uint256 running;
        uint256 released;
        uint256 timestamp;
        bool deleted;
    }

    struct TicketStruct {
        uint256 id;
        uint256 movieId;
        uint256 slotId;
        address owner;
        uint256 cost;
        uint256 timestamp;
        uint256 day;
        bool used;
        bool refunded;
    }

    struct TicketBuildStruct {
        string name;
        string description;
        string bgHue;
        string textHue;
        string value;
        TicketStruct ticket;
    }

    struct TimeSlotStruct {
        uint256 id;
        uint256 movieId;
        uint256 ticketCost;
        uint256 startTime;
        uint256 endTime;
        uint256 capacity;
        uint256 seats;
        bool deleted;
        bool completed;
        uint256 day;
        uint256 balance;
    }

    // Event from DappShared
    event Action(string actionType);

    uint256 public balance;
    string public name;
    string public symbol;

    // Mappings from DappTickets
    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => TicketBuildStruct) public ticketBuild;
    mapping(uint256 => address[]) ticketHolder;

    // Mappings from DappCinemas
    mapping(uint256 => bool) movieExists;
    mapping(uint256 => MovieStruct) movies;
    mapping(uint256 => TimeSlotStruct) movieTimeSlot;

    // Include all functions from DappShared, DappTickets, and DappCinemas here...

    constructor(string memory _name, string memory _symbol) ERC1155("") {
        name = _name;
        symbol = _symbol;
    }

    // Movie related functions
    function addMovie(
        string memory _name,
        string memory _banner,
        string memory _imageUrl,
        string memory _videoUrl,
        string memory _genre,
        string memory _description,
        string memory _caption,
        string memory _casts,
        uint256 _running,
        uint256 _released
    ) public onlyOwner {
        _totalMovies.increment();
        uint256 newMovieId = _totalMovies.current();

        MovieStruct memory movie;
        movie.id = newMovieId;
        movie.name = _name;
        movie.banner = _banner;
        movie.imageUrl = _imageUrl;
        movie.videoUrl = _videoUrl;
        movie.genre = _genre;
        movie.description = _description;
        movie.caption = _caption;
        movie.casts = _casts;
        movie.running = _running;
        movie.released = _released;
        movie.timestamp = currentTime();

        movies[newMovieId] = movie;
        movieExists[newMovieId] = true;

        emit Action("Movie added");
    }

    function updateMovie(
        uint256 _movieId,
        string memory _name,
        string memory _banner,
        string memory _imageUrl,
        string memory _videoUrl,
        string memory _genre,
        string memory _description,
        string memory _caption,
        string memory _casts,
        uint256 _running,
        uint256 _released
    ) public onlyOwner {
        require(movieExists[_movieId], "Movie does not exist");

        movies[_movieId].name = _name;
        movies[_movieId].banner = _banner;
        movies[_movieId].imageUrl = _imageUrl;
        movies[_movieId].videoUrl = _videoUrl;
        movies[_movieId].genre = _genre;
        movies[_movieId].description = _description;
        movies[_movieId].caption = _caption;
        movies[_movieId].casts = _casts;
        movies[_movieId].running = _running;
        movies[_movieId].released = _released;

        emit Action("Movie updated");
    }

    function deleteMovie(uint256 _movieId) public onlyOwner {
        require(movieExists[_movieId], "Movie does not exist");

        movies[_movieId].deleted = true;
        movieExists[_movieId] = false;

        emit Action("Movie deleted");
    }

    // Timeslot related functions
    function addTimeSlot(
        uint256 _movieId,
        uint256 _ticketCost,
        uint256 _startTime,
        uint256 _endTime,
        uint256 _capacity,
        uint256 _day
    ) public onlyOwner {
        require(movieExists[_movieId], "Movie does not exist");

        _totalSlots.increment();
        uint256 newSlotId = _totalSlots.current();

        TimeSlotStruct memory timeSlot;
        timeSlot.id = newSlotId;
        timeSlot.movieId = _movieId;
        timeSlot.ticketCost = _ticketCost;
        timeSlot.startTime = _startTime;
        timeSlot.endTime = _endTime;
        timeSlot.capacity = _capacity;
        timeSlot.seats = 0;
        timeSlot.deleted = false;
        timeSlot.completed = false;
        timeSlot.day = _day;
        timeSlot.balance = 0;

        movieTimeSlot[newSlotId] = timeSlot;

        emit Action("Timeslot added");
    }

    function deleteTimeSlot(uint256 _slotId) public onlyOwner {
        movieTimeSlot[_slotId].deleted = true;
        emit Action("Timeslot deleted");
    }

    function completeTimeSlot(uint256 _slotId) public onlyOwner {
        movieTimeSlot[_slotId].completed = true;
        emit Action("Timeslot completed");
    }

    function getMovies() public view returns (MovieStruct[] memory Movies) {
        uint256 totalMovies;
        for (uint256 i = 1; i <= _totalMovies.current(); i++) {
            if (!movies[i].deleted) totalMovies++;
        }

        Movies = new MovieStruct[](totalMovies);

        uint256 index;
        for (uint256 i = 1; i <= _totalMovies.current(); i++) {
            if (!movies[i].deleted) {
                Movies[index++] = movies[i];
            }
        }
    }

    function getMovie(
        uint256 movieId
    ) public view returns (MovieStruct memory) {
        return movies[movieId];
    }

    function getTimeSlotsByDay(
        uint256 day
    ) public view returns (TimeSlotStruct[] memory MovieSlots) {
        uint256 available;
        for (uint256 i = 0; i < _totalSlots.current(); i++) {
            if (
                movieTimeSlot[i + 1].day == day && !movieTimeSlot[i + 1].deleted
            ) {
                available++;
            }
        }

        MovieSlots = new TimeSlotStruct[](available);

        uint256 index;
        for (uint256 i = 0; i < _totalSlots.current(); i++) {
            if (
                movieTimeSlot[i + 1].day == day && !movieTimeSlot[i + 1].deleted
            ) {
                MovieSlots[index].startTime = movieTimeSlot[i + 1].startTime;
                MovieSlots[index++].endTime = movieTimeSlot[i + 1].endTime;
            }
        }
    }

    function getTimeSlot(
        uint256 slotId
    ) public view returns (TimeSlotStruct memory) {
        return movieTimeSlot[slotId];
    }

    function getTimeSlots(
        uint256 movieId
    ) public view returns (TimeSlotStruct[] memory MovieSlots) {
        uint256 available;
        for (uint256 i = 0; i < _totalSlots.current(); i++) {
            if (
                movieTimeSlot[i + 1].movieId == movieId &&
                !movieTimeSlot[i + 1].deleted
            ) {
                available++;
            }
        }

        MovieSlots = new TimeSlotStruct[](available);

        uint256 index;
        for (uint256 i = 0; i < _totalSlots.current(); i++) {
            if (
                movieTimeSlot[i + 1].movieId == movieId &&
                !movieTimeSlot[i + 1].deleted
            ) {
                MovieSlots[index++] = movieTimeSlot[i + 1];
            }
        }
    }

    function deleteTickets(uint256 _slotId) public onlyOwner {
        deleteTimeSlot(_slotId);
        refundTickets(_slotId);
        emit Action("Tickets refunded");
    }

    function completeTickets(uint256 _slotId) public onlyOwner {
        completeTimeSlot(_slotId);
        invalidateTickets(_slotId);
        emit Action("Tickets burnt");
    }

    function buyTickets(uint256 slotId, uint256 tickets) public payable {
        require(
            msg.value >= movieTimeSlot[slotId].ticketCost * tickets,
            "Insufficient amount"
        );
        require(
            movieTimeSlot[slotId].capacity > movieTimeSlot[slotId].seats,
            "Out of capacity"
        );

        for (uint256 i = 0; i < tickets; i++) {
            _totalTickets.increment();
            TicketStruct memory ticket;

            ticket.id = _totalTickets.current();
            ticket.cost = movieTimeSlot[slotId].ticketCost;
            ticket.day = movieTimeSlot[slotId].day;
            ticket.slotId = slotId;
            ticket.owner = msg.sender;
            ticket.timestamp = currentTime();

            ticketBuild[ticket.id].ticket = ticket;
            ticketHolder[slotId].push(msg.sender);
        }

        movieTimeSlot[slotId].seats += tickets;
        movieTimeSlot[slotId].balance += movieTimeSlot[slotId].ticketCost * tickets;

        mintBatch(tickets);
    }

    function mintBatch(uint256 _numOfTickets) internal {
        uint256[] memory ids = new uint256[](_numOfTickets);
        uint256[] memory amounts = new uint256[](_numOfTickets);
        uint256 _tokenId = _totalTickets.current() - _numOfTickets;

        for (uint256 i = 0; i < _numOfTickets; i++) {
            _tokenId++;
            string memory ticketNumber = Strings.toString(_tokenId);
            string memory ticketValue = string(
                abi.encodePacked(symbol, " #", ticketNumber)
            );
            string
                memory description = "These NFTs are actually tickets for Dapp Cinemas.";

            ticketBuild[_tokenId].name = ticketValue;
            ticketBuild[_tokenId].description = description;
            ticketBuild[_tokenId].bgHue = Strings.toString(
                randomNum(361, currentTime(), _tokenId)
            );
            ticketBuild[_tokenId].textHue = Strings.toString(
                randomNum(361, block.timestamp, _tokenId)
            );
            ticketBuild[_tokenId].value = ticketValue;

            _tokenURIs[_tokenId] = uri(_tokenId);
            ids[i] = _tokenId;
            amounts[i] = 1;
        }

        bytes memory defaultByteData = abi.encodePacked(ids, amounts);
        _mintBatch(msg.sender, ids, amounts, defaultByteData);
    }

    function invalidateTickets(uint256 slotId) internal onlyOwner {
        require(movieTimeSlot[slotId].id == slotId, "Slot not found");

        for (uint256 i = 1; i <= _totalTickets.current(); i++) {
            if (ticketBuild[i].ticket.id == i && !ticketBuild[i].ticket.used) {
                ticketBuild[i].ticket.used = true;
                balance += ticketBuild[i].ticket.cost;
            }
        }
    }

    function refundTickets(uint256 slotId) internal onlyOwner {
        require(movieTimeSlot[slotId].id == slotId, "Slot not found");

        for (uint256 i = 1; i <= _totalTickets.current(); i++) {
            uint256 _tokenId = ticketBuild[i].ticket.id;
            uint256 amount = ticketBuild[i].ticket.cost;
            address owner = ticketBuild[i].ticket.owner;

            if (_tokenId == i && !ticketBuild[i].ticket.used) {
                ticketBuild[i].ticket.refunded = true;
                payTo(owner, amount);
                _burn(owner, _tokenId, 1);
            }
        }
    }

    function getTicketHolders(
        uint256 slotId
    ) public view returns (address[] memory Holders) {
        uint256 available;
        for (uint256 i = 1; i <= _totalTickets.current(); i++) {
            if (
                ticketBuild[i].ticket.slotId == slotId &&
                !ticketBuild[i].ticket.refunded
            ) available++;
        }

        Holders = new address[](available);

        uint256 index;
        for (uint256 i = 1; i <= _totalTickets.current(); i++) {
            if (
                ticketBuild[i].ticket.slotId == slotId &&
                !ticketBuild[i].ticket.refunded
            ) {
                Holders[index++] = ticketBuild[i].ticket.owner;
            }
        }
    }

    function withdrawTo(address to, uint256 amount) public onlyOwner {
        require(balance >= amount, "Insufficient fund");
        balance -= amount;
        payTo(to, amount);
    }

    function uri(uint256 tokenId) public view override returns (string memory) {
        return buildMetadata(tokenId);
    }

    function buildImage(uint256 _tid) internal view returns (string memory) {
        TicketBuildStruct memory currentTicket = ticketBuild[_tid];

        return
            Base64.encode(
                bytes(
                    abi.encodePacked(
                        '<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg">',
                        '<rect height="500" width="500" fill="hsl(',
                        currentTicket.bgHue,
                        ', 50%, 25%)"/>',
                        '<text x="50%" y="50%" dominant-baseline="middle" fill="hsl(',
                        currentTicket.textHue,
                        ', 100%, 80%)" text-anchor="middle" font-size="41">',
                        currentTicket.value,
                        "</text>",
                        "</svg>"
                    )
                )
            );
    }

    function buildMetadata(uint256 _tid) internal view returns (string memory) {
        TicketBuildStruct memory currentTicket = ticketBuild[_tid];
        return
            string(
                abi.encodePacked(
                    "data:application/json;base64,",
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                '{"name":"',
                                currentTicket.name,
                                '", "description":"',
                                currentTicket.description,
                                '", "image": "',
                                "data:image/svg+xml;base64,",
                                buildImage(_tid),
                                '", "attributes": [{"trait_type": "Background Hue", "value": "',
                                currentTicket.bgHue,
                                '"}, {"trait_type": "Text Hue", "value": "',
                                currentTicket.textHue,
                                '"}]}'
                            )
                        )
                    )
                )
            );
    }

    function currentTime() internal view returns (uint256) {
        uint256 newNum = (block.timestamp * 1000) + 1000;
        return newNum;
    }

    function randomNum(
        uint256 _mod,
        uint256 _seed,
        uint256 _salt
    ) internal view returns (uint256) {
        uint256 num = uint256(
            keccak256(
                abi.encodePacked(block.timestamp, msg.sender, _seed, _salt)
            )
        ) % _mod;
        return num;
    }

    function payTo(address to, uint256 amount) internal {
        (bool success, ) = payable(to).call{value: amount}("");
        require(success);
    }

    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC1155, AccessControl) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
